From 2042c16e71339e68fd87156d0183e3b9f9c2f9d1 Mon Sep 17 00:00:00 2001
From: hmz007 <hmz007@gmail.com>
Date: Thu, 21 Nov 2019 17:26:17 +0800
Subject: [PATCH 16/73] block/partitions: add rockchip partition support for
 mmc

Signed-off-by: hmz007 <hmz007@gmail.com>
---
 .../dts/rockchip/rk3328-nanopi-r2-common.dtsi |   1 +
 block/partitions/Kconfig                      |  10 +
 block/partitions/Makefile                     |   1 +
 block/partitions/rk.c                         | 320 ++++++++++++++++++
 block/partitions/rk.h                         |  50 +++
 drivers/mmc/core/block.c                      |   4 +
 include/linux/genhd.h                         |   5 +
 8 files changed, 395 insertions(+)
 create mode 100644 block/partitions/rk.c
 create mode 100644 block/partitions/rk.h

diff --git a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi
index 656cbb967f4b..24293896d64a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3328-nanopi-r2-common.dtsi
@@ -189,6 +189,7 @@ &emmc {
 	cap-mmc-highspeed;
 	max-frequency = <150000000>;
 	mmc-hs200-1_8v;
+	no-sd;
 	non-removable;
 	pinctrl-names = "default";
 	pinctrl-0 = <&emmc_clk &emmc_cmd &emmc_bus8>;
diff --git a/block/partitions/Kconfig b/block/partitions/Kconfig
index 702689a628f0..50bbebaac83c 100644
--- a/block/partitions/Kconfig
+++ b/block/partitions/Kconfig
@@ -262,6 +262,16 @@ config SYSV68_PARTITION
 	  sysv68).
 	  Otherwise, say N.
 
+config RK_PARTITION
+	bool "Rockchip partition table support" if PARTITION_ADVANCED
+	default y if ARCH_ROCKCHIP
+	help
+	  Like most systems, Rockchip use its own hard disk partition table
+	  format, incompatible with all others. Say Y here if you would like
+	  to be able to read the hard disk partition table format used by
+	  Rockchip SoCs inside machines with eMMC as main storage disk.
+	  Otherwise, say N.
+
 config CMDLINE_PARTITION
 	bool "Command line partition support" if PARTITION_ADVANCED
 	select BLK_CMDLINE_PARSER
diff --git a/block/partitions/Makefile b/block/partitions/Makefile
index 2f276b677c81..1fb98d1191ad 100644
--- a/block/partitions/Makefile
+++ b/block/partitions/Makefile
@@ -21,3 +21,4 @@ obj-$(CONFIG_IBM_PARTITION) += ibm.o
 obj-$(CONFIG_EFI_PARTITION) += efi.o
 obj-$(CONFIG_KARMA_PARTITION) += karma.o
 obj-$(CONFIG_SYSV68_PARTITION) += sysv68.o
+obj-$(CONFIG_RK_PARTITION) += rk.o
diff --git a/block/partitions/rk.c b/block/partitions/rk.c
new file mode 100644
index 000000000000..398370714db0
--- /dev/null
+++ b/block/partitions/rk.c
@@ -0,0 +1,320 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include "check.h"
+#include "rk.h"
+
+/* rkpart_setup() parses into here */
+static struct cmdline_rk_partition *partitions;
+
+/* the command line passed to mtdpart_setupd() */
+static char *cmdline;
+static int cmdline_parsed;
+
+/*
+ * Parse one partition definition for an rkpart. Since there can be many
+ * comma separated partition definitions, this function calls itself
+ * recursively until no more partition definitions are found. Nice side
+ * effect: the memory to keep the rk_partition structs and the names
+ * is allocated upon the last definition being found. At that point the
+ * syntax has been verified ok.
+ */
+static struct rk_partition *newpart(char *s, char **retptr,
+		int *num_parts, int this_part,
+		unsigned char **extra_mem_ptr, int extra_mem_size)
+{
+	struct rk_partition *parts;
+	sector_t size;
+	sector_t from = OFFSET_CONTINUOUS;
+	char *name;
+	int name_len;
+	unsigned char *extra_mem;
+	char delim;
+
+	/* fetch the partition size */
+	if (*s == '-') {
+		/* assign all remaining space to this partition */
+		size = SIZE_REMAINING;
+		s++;
+	} else {
+		size = memparse(s, &s);
+		/* No sense support partition less than 8B */
+		if (size < ((PAGE_SIZE) >> 9)) {
+			printk(KERN_ERR ERRP "partition size too small (%llx)\n", (u64)size);
+			return NULL;
+		}
+	}
+
+	/* fetch partition name */
+	delim = 0;
+	/* check for from */
+	if (*s == '@') {
+		s++;
+		from = memparse(s, &s);
+	}
+	/* now look for name */
+	if (*s == '(') {
+		delim = ')';
+	}
+
+	if (delim) {
+		char *p;
+		name = ++s;
+		p = strchr(name, delim);
+		if (!p) {
+			printk(KERN_ERR ERRP "no closing %c found in partition name\n", delim);
+			return NULL;
+		}
+		name_len = p - name;
+		s = p + 1;
+	} else {
+		name = NULL;
+		name_len = 13; /* Partition_000 */
+	}
+
+	/* record name length for memory allocation later */
+	extra_mem_size += name_len + 1;
+
+	/* test if more partitions are following */
+	if (*s == ',') {
+		if (size == SIZE_REMAINING) {
+			printk(KERN_ERR ERRP "no partitions allowed after a fill-up partition\n");
+			return NULL;
+		}
+		/* more partitions follow, parse them */
+		parts = newpart(s + 1, &s, num_parts, this_part + 1,
+				&extra_mem, extra_mem_size);
+		if (!parts)
+			return NULL;
+	} else {
+		/* this is the last partition: allocate space for all */
+		int alloc_size;
+
+		*num_parts = this_part + 1;
+		alloc_size = *num_parts * sizeof(struct rk_partition) + extra_mem_size;
+		parts = kzalloc(alloc_size, GFP_KERNEL);
+		if (!parts) {
+			printk(KERN_ERR ERRP "out of memory\n");
+			return NULL;
+		}
+		extra_mem = (unsigned char *)(parts + *num_parts);
+	}
+
+	/* enter this partition (from will be calculated later if it is zero at this point) */
+	parts[this_part].size = size;
+	parts[this_part].from = from;
+	if (name) {
+		strlcpy(extra_mem, name, name_len + 1);
+	} else {
+		sprintf(extra_mem, "Partition_%03d", this_part);
+	}
+	parts[this_part].name = extra_mem;
+	extra_mem += name_len + 1;
+
+	dbg(("partition %d: name <%s>, from %llx, size %llx\n",
+		this_part,
+		parts[this_part].name,
+		parts[this_part].from,
+		parts[this_part].size));
+
+	/* return (updated) pointer to extra_mem memory */
+	if (extra_mem_ptr)
+		*extra_mem_ptr = extra_mem;
+
+	/* return (updated) pointer command line string */
+	*retptr = s;
+
+	/* return partition table */
+	return parts;
+}
+
+/*
+ * Parse the command line.
+ */
+static int rkpart_setup_real(char *s)
+{
+	cmdline_parsed = 1;
+
+	for ( ; s != NULL; ) {
+		struct cmdline_rk_partition *this_rk;
+		struct rk_partition *parts;
+		int rk_id_len;
+		int num_parts;
+		char *p, *rk_id;
+
+		rk_id = s;
+		/* fetch <rk-id> */
+		if (!(p = strchr(s, ':'))) {
+			dbg(( "no rk-id\n"));
+			return 0;
+		}
+		rk_id_len = p - rk_id;
+
+		dbg(("parsing <%s>\n", p + 1));
+
+		/*
+		 * parse one mtd. have it reserve memory for the
+		 * struct cmdline_mtd_partition and the mtd-id string.
+		 */
+		parts = newpart(p + 1,		/* cmdline */
+				&s,		/* out: updated cmdline ptr */
+				&num_parts,	/* out: number of parts */
+				0,		/* first partition */
+				(unsigned char**)&this_rk, /* out: extra mem */
+				rk_id_len + 1 + sizeof(*this_rk) +
+				sizeof(void*)-1 /*alignment*/);
+		if (!parts) {
+			/*
+			 * An error occurred. We're either:
+			 * a) out of memory, or
+			 * b) in the middle of the partition spec
+			 * Either way, this mtd is hosed and we're
+			 * unlikely to succeed in parsing any more
+			 */
+			 return 0;
+		 }
+
+		/* align this_rk */
+		this_rk = (struct cmdline_rk_partition *)
+			ALIGN((unsigned long)this_rk, sizeof(void*));
+		/* enter results */
+		this_rk->parts = parts;
+		this_rk->num_parts = num_parts;
+		this_rk->rk_id = (char*)(this_rk + 1);
+		strlcpy(this_rk->rk_id, rk_id, rk_id_len + 1);
+
+		/* link into chain */
+		this_rk->next = partitions;
+		partitions = this_rk;
+
+		dbg(("rkid=<%s> num_parts=<%d>\n",
+			 this_rk->mtd_id, this_rk->num_parts));
+
+		/* EOS - we're done */
+		if (*s == 0)
+			break;
+		s++;
+	}
+
+	return 1;
+}
+
+/*
+ * Main function to be called from the MTD mapping driver/device to
+ * obtain the partitioning information. At this point the command line
+ * arguments will actually be parsed and turned to struct mtd_partition
+ * information. It returns partitions for the requested mtd device, or
+ * the first one in the chain if a NULL mtd_id is passed in.
+ */
+static int parse_cmdline_partitions(sector_t n,
+		struct rk_partition **pparts, unsigned long origin)
+{
+	unsigned long from;
+	int i;
+	struct cmdline_rk_partition *part;
+	/* Fixme: parameter should be coherence with part table id */
+	const char *rk_id = "rk29xxnand";
+
+	/* parse command line */
+	if (!cmdline_parsed)
+		rkpart_setup_real(cmdline);
+
+	for (part = partitions; part; part = part->next) {
+		if ((!rk_id) || (!strcmp(part->rk_id, rk_id))) {
+			for (i = 0, from = 0; i < part->num_parts; i++) {
+				if (part->parts[i].from == OFFSET_CONTINUOUS)
+					part->parts[i].from = from;
+				else
+					from = part->parts[i].from;
+				if (part->parts[i].size == SIZE_REMAINING)
+					part->parts[i].size = n - from - FROM_OFFSET;
+
+				if (from + part->parts[i].size > n) {
+					printk(KERN_WARNING ERRP
+						"%s: partitioning exceeds flash size, truncating\n",
+						part->rk_id);
+					part->parts[i].size = n - from;
+					part->num_parts = i;
+				}
+				from += part->parts[i].size;
+			}
+
+			*pparts = kmemdup(part->parts,
+					sizeof(*part->parts) * part->num_parts,
+					GFP_KERNEL);
+			if (!*pparts)
+				return -ENOMEM;
+			return part->num_parts;
+		}
+	}
+
+	return 0;
+}
+
+static void rkpart_bootmode_fixup(void)
+{
+	const char mode_emmc[] = " androidboot.mode=emmc";
+	const char mode_nvme[] = " androidboot.mode=nvme";
+	const char charger[] = " androidboot.charger.emmc=1";
+	char *new_command_line;
+	size_t saved_command_line_len = strlen(saved_command_line);
+
+	if (strstr(saved_command_line, "androidboot.mode=charger")) {
+		new_command_line = kzalloc(saved_command_line_len +
+				strlen(charger) + 1, GFP_KERNEL);
+		sprintf(new_command_line, "%s%s",
+			saved_command_line, charger);
+	} else {
+		new_command_line = kzalloc(saved_command_line_len +
+				strlen(mode_emmc) + 1, GFP_KERNEL);
+		if (strstr(saved_command_line, "storagemedia=nvme"))
+			sprintf(new_command_line, "%s%s",
+				saved_command_line, mode_nvme);
+		else
+			sprintf(new_command_line, "%s%s",
+				saved_command_line, mode_emmc);
+	}
+	saved_command_line = new_command_line;
+}
+
+int rkpart_partition(struct parsed_partitions *state)
+{
+	int num_parts = 0, i;
+	sector_t n = get_capacity(state->bdev->bd_disk);
+	struct rk_partition *parts = NULL;
+
+	if (n < SECTOR_1G)
+		return 0;
+
+	if (!(state->bdev->bd_disk->flags & GENHD_FL_RKPART))
+		return 0;
+
+	/* Fixme: parameter should be coherence with part table */
+	cmdline = strstr(saved_command_line, "mtdparts=");
+	if (!cmdline)
+		return 0;
+	cmdline += 9;
+	cmdline_parsed = 0;
+
+	num_parts = parse_cmdline_partitions(n, &parts, 0);
+	if (num_parts < 0)
+		return num_parts;
+
+	for (i = 0; i < num_parts; i++) {
+		put_partition(state,
+				i+1,
+				parts[i].from + FROM_OFFSET,
+				parts[i].size);
+		strcpy(state->parts[i+1].info.volname, parts[i].name);
+		printk(KERN_INFO "%10s: 0x%09llx -- 0x%09llx (%llu MB)\n", 
+				parts[i].name,
+				(u64)parts[i].from * 512,
+				(u64)(parts[i].from + parts[i].size) * 512,
+				(u64)parts[i].size / 2048);
+	}
+
+	rkpart_bootmode_fixup();
+
+	return 1;
+}
+
diff --git a/block/partitions/rk.h b/block/partitions/rk.h
new file mode 100644
index 000000000000..3840f6efcced
--- /dev/null
+++ b/block/partitions/rk.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * block/partitions/rk.h
+ */
+
+#ifndef FS_PART_RK_H_INCLUDED
+#define FS_PART_RK_H_INCLUDED
+
+/* error message prefix */
+#define ERRP "rkpart: "
+
+/* debug macro */
+#define RKPART_DEBUG		0
+
+#if RKPART_DEBUG
+#define dbg(x) \
+	do { \
+		printk("DEBUG-CMDLINE-PART: "); \
+		printk x; \
+	} while (0)
+#else
+#define dbg(x)
+#endif
+
+/* At least 1GB disk support*/
+#define SECTOR_1G		0x200000
+
+/* Default partition table offet got from loader: 4MB*/
+#define FROM_OFFSET		0x2000
+
+/* special size referring to all the remaining space in a partition */
+#define SIZE_REMAINING		UINT_MAX
+#define OFFSET_CONTINUOUS	UINT_MAX
+
+struct rk_partition {
+	char *name;
+	sector_t from;
+	sector_t size;
+};
+
+struct cmdline_rk_partition {
+	struct cmdline_rk_partition *next;
+	char *rk_id;
+	int num_parts;
+	struct rk_partition *parts;
+};
+
+extern int rkpart_partition(struct parsed_partitions *state);
+
+#endif
diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 2c71a434c915..b5eee292bce9 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -2358,6 +2358,10 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	if (area_type & (MMC_BLK_DATA_AREA_RPMB | MMC_BLK_DATA_AREA_BOOT))
 		md->disk->flags |= GENHD_FL_NO_PART_SCAN
 				   | GENHD_FL_SUPPRESS_PARTITION_INFO;
+#if defined(CONFIG_RK_PARTITION)
+	else if (card->host->caps2 & MMC_CAP2_NO_SD)
+		md->disk->flags |= GENHD_FL_RKPART;
+#endif
 
 	/*
 	 * As discussed on lkml, GENHD_FL_REMOVABLE should:
diff --git a/include/linux/genhd.h b/include/linux/genhd.h
index 8b5330dd5ac0..07899f95c92c 100644
--- a/include/linux/genhd.h
+++ b/include/linux/genhd.h
@@ -145,6 +145,11 @@ struct hd_struct {
 #define GENHD_FL_NO_PART_SCAN			512
 #define GENHD_FL_HIDDEN				1024
 
+#if defined(CONFIG_RK_PARTITION)
+/* Flag of rockchip specific disk: eMMC/eSD, NVMe, etc. */
+#define GENHD_FL_RKPART				2048
+#endif
+
 enum {
 	DISK_EVENT_MEDIA_CHANGE			= 1 << 0, /* media changed */
 	DISK_EVENT_EJECT_REQUEST		= 1 << 1, /* eject requested */
-- 
2.31.1

